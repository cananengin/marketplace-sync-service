import { Prisma, Store, Marketplace, SyncStatus } from '@prisma/client';
import { getPrismaClient } from '../infrastructure/database';
import { generateUuidV7 } from '../infrastructure/database/uuid-v7';

export class StoreRepository {
  private prisma = getPrismaClient();

  async findById(id: string): Promise<Store | null> {
    return this.prisma.store.findUnique({
      where: { id },
    });
  }

  async findBySyncToken(syncToken: string): Promise<Store | null> {
    return this.prisma.store.findUnique({
      where: { syncToken },
    });
  }

  async findByUniqueKey(
    organizationId: string,
    marketplace: Marketplace,
    externalStoreId: string
  ): Promise<Store | null> {
    return this.prisma.store.findUnique({
      where: {
        organizationId_marketplace_externalStoreId: {
          organizationId,
          marketplace,
          externalStoreId,
        },
      },
    });
  }

  async create(data: {
    organizationId: string;
    marketplace: Marketplace;
    externalStoreId: string;
    storeName: string;
    accessToken: string;
    currency: string;
    // Explicitly exclude id and syncToken from data to ensure they are always generated
  } & { id?: never; syncToken?: never }): Promise<Store> {
    // Runtime guard: ensure id is not provided
    if ('id' in data && data.id !== undefined) {
      throw new Error('Store id must be generated by the repository. Do not provide id in create data.');
    }
    if ('syncToken' in data && data.syncToken !== undefined) {
      throw new Error('Store syncToken must be generated by the repository. Do not provide syncToken in create data.');
    }

    const id = generateUuidV7();
    const syncToken = generateUuidV7();
    const now = new Date();
    return this.prisma.store.create({
      data: {
        id,
        ...data,
        syncToken,
        createdAt: now,
        updatedAt: now,
      },
    });
  }

  async update(id: string, data: Partial<{
    storeName: string;
    accessToken: string;
    currency: string;
    syncStatus: SyncStatus;
    lastSyncAt: Date;
    importedSuccessCount: number;
  }>): Promise<Store> {
    return this.prisma.store.update({
      where: { id },
      data: {
        ...data,
        updatedAt: new Date(),
      },
    });
  }

  async updateSyncStatus(
    id: string,
    syncStatus: SyncStatus,
    lastSyncAt?: Date,
    importedSuccessCount?: number
  ): Promise<Store> {
    return this.prisma.store.update({
      where: { id },
      data: {
        syncStatus,
        ...(lastSyncAt && { lastSyncAt }),
        ...(importedSuccessCount !== undefined && { importedSuccessCount }),
        updatedAt: new Date(),
      },
    });
  }

  /**
   * Atomically increment importedSuccessCount
   * Uses database-level increment to ensure atomicity
   */
  async incrementImportedSuccessCount(id: string, incrementBy: number = 1): Promise<Store> {
    return this.prisma.store.update({
      where: { id },
      data: {
        importedSuccessCount: {
          increment: incrementBy,
        },
        updatedAt: new Date(),
      },
    });
  }

  /**
   * Atomically update sync status and increment importedSuccessCount in a transaction
   */
  async updateSyncStatusAndIncrementCount(
    id: string,
    syncStatus: SyncStatus,
    lastSyncAt?: Date,
    incrementBy: number = 1
  ): Promise<Store> {
    return this.prisma.$transaction(async (tx) => {
      return tx.store.update({
        where: { id },
        data: {
          syncStatus,
          ...(lastSyncAt && { lastSyncAt }),
          importedSuccessCount: {
            increment: incrementBy,
          },
          updatedAt: new Date(),
        },
      });
    });
  }

  async findStoresWithFailedOrPendingSync(): Promise<Store[]> {
    return this.prisma.store.findMany({
      where: {
        syncStatus: {
          in: [SyncStatus.failed, SyncStatus.pending],
        },
      },
    });
  }

  /**
   * Find stores eligible for sync (for scheduler).
   * syncStatus IN (pending, failed, partial).
   * Optional throttle: lastSyncAt older than throttleMinutes or null.
   * Cursor pagination by (createdAt, id) for stable ordering.
   */
  async findStoresEligibleForSync(
    limit: number,
    cursor?: { createdAt: Date; id: string },
    options?: { throttleMinutes?: number }
  ): Promise<{ stores: Store[]; nextCursor: { createdAt: Date; id: string } | null }> {
    const throttleMinutes = options?.throttleMinutes ?? 1;
    const throttleCutoff = new Date(Date.now() - throttleMinutes * 60 * 1000);

    const where: Prisma.StoreWhereInput = {
      syncStatus: {
        in: [SyncStatus.pending, SyncStatus.failed, SyncStatus.partial],
      },
      OR: [
        { lastSyncAt: null },
        { lastSyncAt: { lt: throttleCutoff } },
      ],
    };

    // Cursor: (createdAt > cAt) OR (createdAt = cAt AND id > cId) for stable pagination
    if (cursor) {
      const cAt = cursor.createdAt;
      const cId = cursor.id;
      where.AND = [
        {
          OR: [
            { createdAt: { gt: cAt } },
            { createdAt: cAt, id: { gt: cId } },
          ],
        },
      ];
    }

    const stores = await this.prisma.store.findMany({
      where,
      orderBy: [{ createdAt: 'asc' }, { id: 'asc' }],
      take: limit + 1,
    });

    const hasMore = stores.length > limit;
    const slice = hasMore ? stores.slice(0, limit) : stores;
    const nextCursor =
      hasMore && slice.length > 0
        ? {
            createdAt: slice[slice.length - 1].createdAt,
            id: slice[slice.length - 1].id,
          }
        : null;

    return { stores: slice, nextCursor };
  }

  async countByOrganization(organizationId: string): Promise<number> {
    return this.prisma.store.count({
      where: { organizationId },
    });
  }
}
