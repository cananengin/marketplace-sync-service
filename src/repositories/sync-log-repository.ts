import { Prisma, SyncLog, SyncLogStatus } from '@prisma/client';
import { getPrismaClient } from '../infrastructure/database';
import { generateUuidV7 } from '../infrastructure/database/uuid-v7';

export class SyncLogRepository {
  private prisma = getPrismaClient();

  async findById(id: string): Promise<SyncLog | null> {
    return this.prisma.syncLog.findUnique({
      where: { id },
    });
  }

  async findByStoreAndReceipt(storeId: string, receipt: string): Promise<SyncLog | null> {
    return this.prisma.syncLog.findUnique({
      where: {
        storeId_receipt: {
          storeId,
          receipt,
        },
      },
    });
  }

  async create(data: {
    storeId: string;
    receipt: string;
    status?: SyncLogStatus;
    orderId?: string;
    amount?: number;
    currency?: string;
    errorDetails?: string;
    attempt?: number;
    nextRetryAt?: Date;
    importedAt?: Date;
    // Explicitly exclude id from data to ensure it is always generated
  } & { id?: never }): Promise<SyncLog> {
    // Runtime guard: ensure id is not provided
    if ('id' in data && data.id !== undefined) {
      throw new Error('SyncLog id must be generated by the repository. Do not provide id in create data.');
    }

    const id = generateUuidV7();
    const now = new Date();
    return this.prisma.syncLog.create({
      data: {
        id,
        ...data,
        status: data.status || SyncLogStatus.pending,
        amount: data.amount ? new Prisma.Decimal(data.amount) : null,
        createdAt: now,
        updatedAt: now,
      },
    });
  }

  async update(id: string, data: Partial<{
    status: SyncLogStatus;
    orderId: string;
    amount: number;
    currency: string;
    errorDetails: string | null;
    attempt: number;
    nextRetryAt: Date | null;
    importedAt: Date;
  }>): Promise<SyncLog> {
    return this.prisma.syncLog.update({
      where: { id },
      data: {
        ...data,
        ...(data.amount !== undefined && { amount: new Prisma.Decimal(data.amount) }),
        updatedAt: new Date(),
      },
    });
  }

  /**
   * Find pending/failed/rate_limited logs. Optional storeId filter, optional limit.
   * @param storeIdOrLimit - when string: filter by storeId; when number: limit only
   * @param limit - when first arg is storeId, this is the limit
   */
  async findPendingOrFailedLogs(
    storeIdOrLimit?: string | number,
    limit?: number
  ): Promise<SyncLog[]> {
    const storeId = typeof storeIdOrLimit === 'string' ? storeIdOrLimit : undefined;
    const takeLimit =
      typeof storeIdOrLimit === 'number' ? storeIdOrLimit : limit;
    return this.prisma.syncLog.findMany({
      where: {
        ...(storeId && { storeId }),
        status: {
          in: [SyncLogStatus.pending, SyncLogStatus.failed, SyncLogStatus.rate_limited],
        },
        OR: [
          { nextRetryAt: null },
          { nextRetryAt: { lte: new Date() } },
        ],
      },
      orderBy: [
        { nextRetryAt: 'asc' },
        { createdAt: 'asc' },
      ],
      ...(takeLimit !== undefined && takeLimit > 0 && { take: takeLimit }),
    });
  }

  async findByStoreId(storeId: string, limit?: number): Promise<SyncLog[]> {
    return this.prisma.syncLog.findMany({
      where: { storeId },
      orderBy: { createdAt: 'desc' },
      ...(limit && { take: limit }),
    });
  }

  async countByStoreAndStatus(storeId: string, status: SyncLogStatus): Promise<number> {
    return this.prisma.syncLog.count({
      where: {
        storeId,
        status,
      },
    });
  }

  async getSyncStatsByStore(storeId: string): Promise<{
    total: number;
    success: number;
    failed: number;
    pending: number;
    rate_limited: number;
  }> {
    const [total, success, failed, pending, rate_limited] = await Promise.all([
      this.prisma.syncLog.count({ where: { storeId } }),
      this.prisma.syncLog.count({ where: { storeId, status: SyncLogStatus.success } }),
      this.prisma.syncLog.count({ where: { storeId, status: SyncLogStatus.failed } }),
      this.prisma.syncLog.count({ where: { storeId, status: SyncLogStatus.pending } }),
      this.prisma.syncLog.count({ where: { storeId, status: SyncLogStatus.rate_limited } }),
    ]);

    return { total, success, failed, pending, rate_limited };
  }

  /**
   * Count successful sync logs for a store (source of truth for importedSuccessCount)
   */
  async countSuccessByStoreId(storeId: string): Promise<number> {
    return this.prisma.syncLog.count({
      where: {
        storeId,
        status: SyncLogStatus.success,
      },
    });
  }

  /**
   * Get recent sync logs for a store (for sync status calculation)
   */
  async getRecentLogs(storeId: string, limit: number = 20): Promise<SyncLog[]> {
    return this.prisma.syncLog.findMany({
      where: { storeId },
      orderBy: { createdAt: 'desc' },
      take: limit,
    });
  }

  /**
   * Get processable logs for a store (pending, failed, rate_limited with nextRetryAt due)
   */
  async getProcessableLogsForStore(
    storeId: string,
    limit: number
  ): Promise<SyncLog[]> {
    const now = new Date();
    return this.prisma.syncLog.findMany({
      where: {
        storeId,
        status: {
          in: [SyncLogStatus.pending, SyncLogStatus.failed, SyncLogStatus.rate_limited],
        },
        OR: [
          { nextRetryAt: null },
          { nextRetryAt: { lte: now } },
        ],
      },
      orderBy: [{ createdAt: 'asc' }, { id: 'asc' }],
      take: limit,
    });
  }
}
